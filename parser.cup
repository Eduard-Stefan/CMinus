/*
   Simple +/-/* expression language; 
   parser evaluates constant expressions on the fly
*/

package cup.example;

import java_cup.runtime.*;
import cup.example.Lexer;
import java.io.IOException;
import java.io.File;
import java.io.FileInputStream;

parser code {:
  protected Lexer lexer;
:}

/* define how to connect to the scanner! */
init with {:
  ComplexSymbolFactory f = new ComplexSymbolFactory();
  symbolFactory = f;
  File file = new File("input.txt");
  FileInputStream fis = null;
  try {
    fis = new FileInputStream(file);
  } catch (IOException e) {
    e.printStackTrace();
  } 
  lexer = new Lexer(f,fis);
:};
scan with {: return lexer.next_token(); :};

/* Terminals (tokens returned by the scanner). */
terminal            ELSE, IF, INT, RETURN, VOID, WHILE, PLUS, MINUS, TIMES, DIVIDE, LT, LE, GT, GE, EQ, NE, ASSIGN, SEMI, COMMA, LPAREN, RPAREN, LBRACE, RBRACE, LBRACKET, RBRACKET, ID;
terminal Integer    NUM;

/* Non terminals */
non terminal program;
non terminal declaration_list;
non terminal declaration;
non terminal var_declaration;
non terminal type_specifier;
non terminal fun_declaration;
non terminal params;
non terminal param_list;
non terminal param;
non terminal compound_stmt;
non terminal local_declarations;
non terminal statement_list;
non terminal statement;
non terminal expression_stmt;
non terminal selection_stmt;
non terminal iteration_stmt;
non terminal return_stmt;
non terminal expression;
non terminal var;
non terminal simple_expression;
non terminal relop;
non terminal additive_expression;
non terminal addop;
non terminal term;
non terminal mulop;
non terminal factor;
non terminal call;
non terminal args;
non terminal arg_list;

/* Precedences */
precedence left PLUS, MINUS;
precedence left TIMES, DIVIDE;
precedence left ELSE;

/* The grammar rules */
program             ::= declaration_list
					  ;
declaration_list    ::= declaration_list declaration
					  | declaration
					  ;
declaration         ::= var_declaration
					  | fun_declaration
					  ;
var_declaration     ::= type_specifier ID SEMI
					  | type_specifier ID LBRACKET NUM RBRACKET SEMI
					  ;
type_specifier      ::= INT
					  | VOID
					  ;
fun_declaration     ::= type_specifier ID LPAREN params RPAREN compound_stmt
					  ;
params              ::= param_list
					  | VOID
					  ;
param_list          ::= param_list COMMA param
					  | param
					  ;
param               ::= type_specifier ID
					  | type_specifier ID LBRACKET RBRACKET
					  ;
compound_stmt       ::= LBRACE local_declarations statement_list RBRACE
					  ;
local_declarations  ::= local_declarations var_declaration
					  | /* empty */
					  ;
statement_list      ::= statement_list statement
					  | /* empty */
					  ;
statement           ::= expression_stmt
					  | compound_stmt
					  | selection_stmt
					  | iteration_stmt
					  | return_stmt
					  ;
expression_stmt     ::= expression SEMI
					  | SEMI
					  ;
selection_stmt      ::= IF LPAREN expression RPAREN statement
					  | IF LPAREN expression RPAREN statement ELSE statement
					  ;
iteration_stmt      ::= WHILE LPAREN expression RPAREN statement
					  ;
return_stmt         ::= RETURN SEMI
					  | RETURN expression SEMI
					  ;
expression          ::= var ASSIGN expression
					  | simple_expression
					  ;
var                 ::= ID
					  | ID LBRACKET expression RBRACKET
					  ;
simple_expression   ::= additive_expression relop additive_expression
					  | additive_expression
					  ;
relop               ::= LE
					  | LT
					  | GT
					  | GE
					  | EQ 
					  | NE
					  ;
additive_expression ::= additive_expression addop term
					  | term
					  ;
addop               ::= PLUS
					  | MINUS
					  ;
term                ::= term mulop factor
					  | factor
					  ;
mulop               ::= TIMES
					  | DIVIDE
					  ;
factor              ::= LPAREN expression RPAREN
					  | var 
					  | call 
					  | NUM
					  ;
call                ::= ID LPAREN args RPAREN
					  ;
args                ::= arg_list 
					  | /* empty */
					  ;
arg_list            ::= arg_list COMMA expression 
					  | expression
					  ;